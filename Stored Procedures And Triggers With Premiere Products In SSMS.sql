--									Stored Procedures And Triggers With Premiere Products In SSMS

-- Load The Data Included In the "Database Creation For Analysis In SSMS" File Before Running The Below Commands.

-- Setting Database To Use
USE GUIDE;

-- Viewing All Premiere Products Tables
SELECT REP_NUM, LAST_NAME, FIRST_NAME, STREET, CITY, STATE, ZIP, FORMAT(COMMISSION, 'C') AS COMMISSION, RATE
FROM REP;

SELECT CUSTOMER_NUM, CUSTOMER_NAME, STREET, CITY, STATE, ZIP, FORMAT(BALANCE, 'C') AS BALANCE , FORMAT(CREDIT_LIMIT, 'C') AS CREDIT_LIMIT, REP_NUM
FROM CUSTOMER;

SELECT ORDER_NUM, ORDER_DATE, CUSTOMER_NUM 
FROM ORDERS;

SELECT ORDER_NUM, PART_NUM, NUM_ORDERED, FORMAT(QUOTED_PRICE, 'C') AS QUOTED_PRICE
FROM ORDER_LINE;

SELECT PART_NUM, DESCRIPTION, ON_HAND, CLASS, WAREHOUSE, FORMAT(PRICE, 'C') AS PRICE
FROM PART;

-- Creating A Stored Procedure To Display Rep Names
CREATE PROCEDURE DISP_REP
@num CHAR(2)
AS SELECT RTRIM(FIRST_NAME)+' '+RTRIM(LAST_NAME)
FROM REP WHERE REP_NUM = @num

-- Execute Procedure
EXEC DISP_REP '20'

-- Creating A Stored Procedure To Display Customer Names
CREATE PROCEDURE DISP_CUS
@num INT
AS SELECT CUSTOMER_NAME FROM CUSTOMER WHERE CUSTOMER_NUM = @num;

-- Execute DISP_CUS Procedure
EXEC DISP_CUS '148';

-- Creating A Stored Procedure To Display Customer Orders
CREATE PROCEDURE CUS_ORDER
@NUM INT
AS SELECT ORDER_DATE, O.CUSTOMER_NUM, CUSTOMER_NAME FROM ORDERS O, CUSTOMER C
WHERE O.CUSTOMER_NUM = C.CUSTOMER_NUM AND ORDER_NUM = @NUM;

-- Execute CUS_ORDER Procedure
EXEC CUS_ORDER '21623';

-- Creating A Stored Procedure To Display Customer Credit Limit
CREATE PROCEDURE CUS_LIMIT
@NUM INT
AS SELECT CUSTOMER_NAME, CREDIT_LIMIT 
FROM CUSTOMER 
WHERE CUSTOMER_NUM = @NUM

-- Execute CUS_LIMIT Procedure
EXEC CUS_LIMIT '356'

-- Creating A Stored Procedure To Change Customer Names
CREATE PROCEDURE CHG_CUST_NAME
@num CHAR(3),
@name VARCHAR(35)
AS UPDATE CUSTOMER 
SET CUSTOMER_NAME = @name
WHERE CUSTOMER_NUM = @num;

-- Execute CHG_CUST_NAME Procedure
EXEC CHG_CUST_NAME '725','Deerfield''s'

SELECT * FROM CUSTOMER WHERE CUSTOMER_NUM = 725;

-- Creating A Stored Procedure To Change Part Price
CREATE PROCEDURE PART_PRICE
@num CHAR(4),
@change DECIMAL(6,2)
AS UPDATE PART
SET PRICE = PRICE + @change
WHERE PART_NUM = @num;

-- Execute PART_PRICE Procedure
EXEC PART_PRICE 'AT94', '2';

SELECT * FROM PART;

-- Creating A Stored Procedure To Add An Order
CREATE PROCEDURE ADD_ORDER
@rnum CHAR(5),
@date VARCHAR(15),
@cnum CHAR(3)
AS INSERT INTO ORDERS VALUES
(@rnum, @date, @cnum);

-- Execute ADD_ORDER Procedure
EXEC ADD_ORDER '21630','05/22/2024','608';

-- Creating A Stored Procedure To Change Order Date
CREATE PROCEDURE CHG_DATE
@num CHAR(5),
@date VARCHAR(10)
AS UPDATE ORDERS
SET ORDER_DATE = @date
WHERE ORDER_NUM = @num;

-- Execute CHG_DATE Procedure
EXEC CHG_DATE '21630','05/23/2024'

-- Creating A Stored Procedure To Delete Orders
CREATE PROCEDURE DEL_ORDER
@num CHAR(5) AS
DELETE FROM ORDER_LINE WHERE ORDER_NUM = @num
DELETE FROM ORDERS WHERE ORDER_NUM = @num;

-- Execute DEL_ORDER Procedure
EXEC DEL_ORDER '21630';

SELECT * FROM ORDERS;
SELECT * FROM ORDER_LINE;

-- Creating A Stored Procedure To Display Customers By Rep Number Using A Cursor
CREATE PROCEDURE REP_CUST
@rnum CHAR(2)
AS
DECLARE @cnum CHAR(3)
DECLARE @cname CHAR(35)
DECLARE mycursor CURSOR READ_ONLY

FOR SELECT CUSTOMER_NUM, CUSTOMER_NAME
FROM CUSTOMER
WHERE REP_NUM = @rnum

OPEN mycursor

FETCH NEXT FROM mycursor
INTO @cnum, @cname

WHILE @@FETCH_STATUS = 0
BEGIN 
	PRINT @cnum+' '+@cname

	FETCH NEXT FROM mycursor
	INTO @cnum, @cname

END

CLOSE mycursor
DEALLOCATE mycursor

-- Execute REP_CUST Procedure
EXEC REP_CUST '20'

-- Creating A Trigger For To Add Commission For New Customer
CREATE TRIGGER ADD_COMM
ON CUSTOMER AFTER INSERT AS

DECLARE @num CHAR(2)
DECLARE @bal DECIMAL(8,2)
SELECT @num = (SELECT REP_NUM FROM INSERTED)
SELECT @bal = (SELECT BALANCE FROM INSERTED)
UPDATE REP
SET COMMISSION = COMMISSION + (@bal * RATE)
WHERE REP_NUM = @num;

-- Testing ADD_COMM Trigger
INSERT INTO CUSTOMER VALUES
('800', 'All', '2 Lake', 'Grove', 'FL', '33321', 8000.00, 10000.00, '20');

SELECT * FROM CUSTOMER;
SELECT * FROM REP;

-- Creating A Trigger To Update Commission When Customer Balance Changes
CREATE TRIGGER UPDATE_COMM
ON CUSTOMER AFTER UPDATE AS

DECLARE @new DECIMAL(8,2)
DECLARE @old DECIMAL(8,2)
DECLARE @num CHAR(2)
SELECT @new = (SELECT BALANCE FROM INSERTED)
SELECT @old = (SELECT BALANCE  FROM DELETED)
SELECT @num = (SELECT REP_NUM FROM INSERTED)
UPDATE REP
SET COMMISSION = COMMISSION + ((@new - @old) * RATE)
WHERE REP_NUM = @num;

-- Testing UPDATE_COMM Trigger
UPDATE CUSTOMER
SET BALANCE = 9000
WHERE CUSTOMER_NUM = '800';

SELECT * FROM CUSTOMER;
SELECT * FROM REP;

-- Creating A Trigger For When A Customer Is Deleted
CREATE TRIGGER DEL_CUST
ON CUSTOMER AFTER DELETE AS

DECLARE @old DECIMAL(8,2)
DECLARE @num CHAR(2)
SELECT @old = (SELECT BALANCE FROM DELETED)
SELECT @num = (SELECT REP_NUM FROM DELETED)
UPDATE REP
SET COMMISSION = COMMISSION - (@old * RATE)
WHERE REP_NUM = @num;

-- Testing DEL_CUST Trigger
DELETE CUSTOMER
WHERE CUSTOMER_NUM = '800';

SELECT * FROM CUSTOMER;
SELECT * FROM REP;

-- Preparing For Trigger Creation
CREATE VIEW OO AS
SELECT PART_NUM, SUM(NUM_ORDERED) AS ON_ORDER FROM ORDER_LINE GROUP BY PART_NUM;

ALTER TABLE PART
ADD ON_ORDER INT;

UPDATE PART
SET PART.ON_ORDER = OO.ON_ORDER
FROM OO
JOIN PART ON PART.PART_NUM = OO.PART_NUM;		

DROP VIEW OO;

SELECT * FROM PART;

-- Creating A Trigger For A New Order
CREATE TRIGGER ADD_ON_ORDER
ON ORDER_LINE AFTER INSERT AS

DECLARE @numb INT
DECLARE @num CHAR(4)
SELECT @numb = (SELECT NUM_ORDERED FROM INSERTED)
SELECT @num = (SELECT PART_NUM FROM INSERTED)
UPDATE PART
SET ON_ORDER = ON_ORDER + @numb
WHERE PART_NUM = @num;

-- Testing ADD_ON_ORDER Trigger
INSERT INTO ORDER_LINE VALUES
('21630', 'FD21', 1, 159.95)

SELECT * FROM ORDER_LINE;
SELECT * FROM PART;

-- Creating A Trigger For An Updated Order
CREATE TRIGGER UPDATE_ORDER_LINE
ON ORDER_LINE AFTER UPDATE AS
DECLARE @new INT
DECLARE @old INT
DECLARE @num CHAR(4)
SELECT @new = (SELECT NUM_ORDERED FROM INSERTED)
SELECT @old = (SELECT NUM_ORDERED FROM DELETED)
SELECT @num = (SELECT PART_NUM FROM INSERTED)
UPDATE PART 
SET ON_ORDER = ON_ORDER + @new - @old
WHERE PART_NUM = @num;

-- Testing UPDATE_ORDER_LINE Trigger
UPDATE ORDER_LINE
SET NUM_ORDERED = '2'
WHERE PART_NUM = 'FD21';

SELECT * FROM ORDER_LINE;
SELECT * FROM PART;

-- Creating A Trigger For A Deleted Order
CREATE TRIGGER DEL_ORDER_LINE
ON ORDER_LINE AFTER DELETE AS
DECLARE @num CHAR(4)
DECLARE @numb INT
SELECT @num = (SELECT PART_NUM FROM DELETED)
SELECT @numb = (SELECT NUM_ORDERED FROM DELETED)
UPDATE PART 
SET ON_ORDER = ON_ORDER - @numb
WHERE PART_NUM = @num;

-- Testing Trigger
EXEC DEL_ORDER '21630';

SELECT * FROM ORDER_LINE;
SELECT * FROM PART;